---
title: "Point patterns"
author: "Mari Myllymäki"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{pointpatterns}
  %\VignetteEngine{knitr::knitr}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


These examples utilize the R package spatstat in addition to the GET package.
```{r setup}
library("GET")
library("spatstat")
```

# Testing simple hypotheses for point patterns and marked point patterns

## Testing complete spatial randomness (CSR)

Let us illustrate the CSR for the spruces data set from the R library spatstat.
```{r spruces}
X <- unmark(spruces)
plot(X)
```

Below we use the function envelope of the spatstat package to generate point patterns under CSR (specified in the argument 'simulate') and to calculate the centred L-functions (specified below by the arguments fun, correction and transform) that we utilize here as the test functions.

```{r csr}
nsim <- 1999 # Number of simulations
env <- envelope(X, fun="Lest", nsim=nsim,
                savefuns=TRUE, # save the functions
                correction="translate", # edge correction for L
                transform = expression(.-r), # centering
                simulate=expression(runifpoint(ex=X)), # Simulate CSR
                verbose=FALSE)
# The rank envelope test (ERL)
res <- global_envelope_test(env, type="erl")
# Plot the result
plot(res)
```

It is possible to cut the functions to an interval of distances $[r_{min}, r_{max}]$ (at the same time creating a curve_set from 'env') and perform the test on the functions on this interval only:
```{r csr_cont}
cset <- crop_curves(env, r_min=1, r_max=7)
# Do the rank envelope test (erl)
res <- global_envelope_test(cset, type="erl")
plot(res, ylab=expression(italic(L(r)-r)))
```

## Testing random labeling of marks

Let know the studied marked point pattern be the spruces data with marks:
```{r spruces_mpp}
mpp <- spruces
plot(mpp)
```

As in the CSR test, to perform the test of random labelling hypothesis, first the envelope function of spatstat can be used to generate simulations and calculate the test function $T(r)$ for the data pattern (mpp) and each simulation.
Below we use as the test function the estimator of the mark-weighted L function, $L_{mm}(r)$, with translational edge correction. The argumen 'simulate' specifies the simulations under the random labeling, i.e. simple permutation of the marks.
```{r randomlabeling}
nsim <- 1999 # Number of simulations
env <- envelope(mpp, fun=Kmark, nsim = nsim, f=function(m1, m2) { m1*m2 },
                correction="translate", returnL=TRUE,
                simulate=expression(rlabel(mpp, permute=TRUE)), # Permute the marks
                savefuns=TRUE, # Save the functions
                verbose=FALSE)
```
Thereafter, the curves can be cropped to the desired r-interval and centered by the mean of the simulated functions for better visualization, before making the test.
```{r randomlabeling_cont}
# Crop curves to desired r-interval
curve_set <- crop_curves(env, r_min=1.5, r_max=9.5)
# Center the functions, i.e. take \hat{L}_mm(r)-the mean of simulated functions.
curve_set <- residual(curve_set)
# The global envelope test
res <- global_envelope_test(curve_set)
plot(res, ylab=expression(italic(L[mm](r)-L(r))))
```


## A combined global envelope test

Sometimes it may be desired to base the test on several test functions. 
Below it is illustrated how the CSR can be tested simultaneously by means of L, F, G and J functions for the saplings data set available in the GET library.


```{r combined}
#================================
data(saplings)
X <- saplings

nsim <- 499 # Number of simulations

# Specify distances for different test functions
n <- 500 # the number of r-values
rmin <- 0; rmax <- 20; rstep <- (rmax-rmin)/n
rminJ <- 0; rmaxJ <- 8; rstepJ <- (rmaxJ-rminJ)/n
r <- seq(0, rmax, by=rstep)    # r-distances for Lest
rJ <- seq(0, rmaxJ, by=rstepJ) # r-distances for Fest, Gest, Jest

# Perform simulations of CSR and calculate the L-functions
env_L <- envelope(X, nsim=nsim,
                simulate=expression(runifpoint(ex=X)),
                fun="Lest", correction="translate",
                transform=expression(.-r), # Take the L(r)-r function instead of L(r)
                r=r,                       # Specify the distance vector
                savefuns=TRUE,             # Save the estimated functions
                savepatterns=TRUE,         # Save the simulated patterns
                verbose=FALSE)
# Take the simulations from the returned object
simulations <- attr(env_L, "simpatterns")
# Then calculate the other test functions F, G, J for each simulated pattern
env_F <- envelope(X, nsim=nsim,
                simulate=simulations,
                fun="Fest", correction="Kaplan", r=rJ,
                savefuns=TRUE, verbose=FALSE)
env_G <- envelope(X, nsim=nsim,
                simulate=simulations,
                fun="Gest", correction="km", r=rJ,
                savefuns=TRUE, verbose=FALSE)
env_J <- envelope(X, nsim=nsim,
                simulate=simulations,
                fun="Jest", correction="none", r=rJ,
                savefuns=TRUE, verbose=FALSE)

# Crop the curves to the desired r-interval I
curve_set_L <- crop_curves(env_L, r_min=rmin, r_max=rmax)
curve_set_F <- crop_curves(env_F, r_min=rminJ, r_max=rmaxJ)
curve_set_G <- crop_curves(env_G, r_min=rminJ, r_max=rmaxJ)
curve_set_J <- crop_curves(env_J, r_min=rminJ, r_max=rmaxJ)

res <- global_envelope_test(curve_sets=list(curve_set_L, curve_set_F,
                                          curve_set_G, curve_set_J))
plot(res, labels=c("L(r)-r", "F(r)", "G(r)", "J(r)"))
```


## Goodness-of-fit test (typically conservative)

It is possible to perform a one-stage goodness-of-fit test for point process models as follows, accepting that the test may be conservative (or liberal). In literature, it has been recommended that the tests may be used if the test function is not closely related to the estimation procedure that was used to fit the model. However, GET.composite can be used for adjusted tests, see the help file of this function and an example below.

```{r gof}
X <- unmark(spruces)
# Minimum distance between points in the pattern
min(nndist(X))
# Fit a model
fittedmodel <- ppm(X, interaction=Hardcore(hc=1)) # Hardcore process

# Simulating Gibbs process by 'envelope' is slow, because it uses the MCMC algorithm
#env <- envelope(fittedmodel, fun="Jest", nsim=999, savefuns=TRUE,
#                correction="none", r=seq(0, 4, length=500))

# Using direct algorihm can be faster, because the perfect simulation is used here.
simulations <- NULL
nsim <- 999 # Number of simulations
for(j in 1:nsim) {
   simulations[[j]] <- rHardcore(beta=exp(fittedmodel$coef[1]),
                                 R=fittedmodel$interaction$par$hc,
                                 W=X$window)
   if(j%%10==0) cat(j, "...", sep="")
}
env <- envelope(X, simulate=simulations, fun="Jest", nsim=length(simulations),
                savefuns=TRUE, correction="none", r=seq(0, 4, length=500), verbose=FALSE)
curve_set <- crop_curves(env, r_min=1, r_max=3.5)
res <- global_envelope_test(curve_set, type="erl"); plot(res, ylab=expression(italic(J(r))))
```


## Adjusted global envelope test

Let us test the fit of a Matern cluster process for the sapling data as an example of a composite hypothesis test.

```{r saplings}
data(saplings)
plot(saplings)
```

First define the r-distances and number of simulations. Here we set the number of simulations just to 19, for fast exploration of the code, but for serious analysis we recommend at least 499 simulations.

```{r adjusted_init}
rmin <- 0.3; rmax <- 10; rstep <- (rmax-rmin)/500
r <- seq(0, rmax, by=rstep)
nsim <- 19 # Increase nsim for serious analysis!
```

The Matern cluster process can be fitted to the pattern using the ppm function of spatstat. This utilizes minimum contrast estimation with the K-function.
```{r adjusted_fit}
M1 <- kppm(saplings~1, clusters = "MatClust", statistic="K")
M1
```
Then the adjusted global area rank envelope test can be performed using the function GET.composite. Below we use the centred L(r) function as the test function. The argument 'type' specifies the global envelope test, see ?global_envelope_test.
```{r adjusted_test}
adjenvL <- GET.composite(X = M1, nsim = nsim,
            testfuns = list(L = list(fun="Lest", correction="translate",
                           transform = expression(.-r), r=r)), # passed to envelope
            type = "area", r_min=rmin, r_max=rmax, verbose=FALSE)
plot(adjenvL)
```

## Testing global and local dependence of point patterns on covariates

The function GET.spatialF performs the one-stage global envelope tests based on spatial F- and S-statistics that were proposed by Myllymäki et al. (2020) to explore the effects of covariates in parametric point process models.

Let us look at a simple example of tropical rain forest trees.
```{r spatialF}
data(bei)
```

Let us study the effect of gradient on the intensity of the trees. We define the full model including this interesting covariate and the reduced model, which is otherwise the same as the full model, but the interesting covariate is excluded. Further the function fitppm defines how the (full or reduced) model can be fitted to the point pattern.
```{r spatialF_bei}
fullmodel <- ~ grad
reducedmodel <- ~ 1
fitppm <- function(X, model, covariates) {
  ppm(X, model, covariates=covariates)
}

nsim <- 19 # Increase nsim for serious analysis!
res <- GET.spatialF(bei, fullmodel, reducedmodel, fitppm, bei.extra, nsim)

plot(res$F)
plot(res$S)
```

Another example is the test of the effect of elevation on the point pattern of lightnings.
```{r spatialF_ff}
# Example of forest fires
data("clmfires")
# Choose the locations of the lightnings in years 2004-2007:
pp.lightning <- unmark(subset(clmfires, cause == "lightning" &
                 date >= "2004-01-01" & date < "2008-01-01"))

covariates <- clmfires.extra$clmcov100
covariates$forest <- covariates$landuse == "conifer" | covariates$landuse == "denseforest" |
                      covariates$landuse == "mixedforest"

fullmodel <- ~ elevation + landuse
reducedmodel <- ~ landuse
nsim <- 19 # Increase nsim for serious analysis!
res <- GET.spatialF(pp.lightning, fullmodel, reducedmodel, fitppm, covariates, nsim)
plot(res$F)
plot(res$S)
```

Above only the inhomogeneous Poisson process was used as the model. Examples of the fitfun functions for clustered and regular processes are:
```{r spatialF_extra}
# fitfun for the log Gaussian Cox Process with exponential covariance function
fitLGCPexp <- function(X, model, covariates) {
  kppm(X, model, clusters="LGCP", model="exponential", covariates=covariates)
}
# fitfun for the hardcore process with hardcore radius 0.01
fitHardcore <- function(X, model, covariates) {
  ppm(X, model, interaction=Hardcore(0.01), covariates = covariates)
}
```

## An example analysis of the saplings data set

This is the example of Myllymaki et al. (2017, Supplement S4).

The saplings data set is available at the GET package.

```{r saplings_data}
data(saplings)
```

First choose the r-distances for L (r) and J (rJ) functions, respectively.

```{r saplings_init}
nr <- 500
rmin <- 0.3; rminJ <- 0.3
rmax <- 10; rmaxJ <- 6
rstep <- (rmax-rmin)/nr; rstepJ <- (rmaxJ-rminJ)/nr
r <- seq(0, rmax, by=rstep)
rJ <- seq(0, rmaxJ, by=rstepJ)
```

### The CSR test based on the L(r)-r function

Note: CSR is simulated by fixing the number of points and generating nsim simulations
from the binomial process, i.e. we deal with a simple hypothesis.

First, the envelope function of the spatstat package can be used to generate nsim simulations under CSR and
to calculate the centred L function for the data and each simulation.
```{r saplings_csr_L}
nsim <- 999 # Number of simulations
env <- envelope(saplings, nsim=nsim,
    simulate=expression(runifpoint(saplings$n, win=saplings$window)), # Simulate CSR
    fun="Lest", correction="translate", # T(r) = estimator of L with translational edge correction
    transform = expression(.-r),        # Take the L(r)-r function instead of L(r)
    r=r,                                # Specify the distance vector
    savefuns=TRUE)                      # Save the estimated functions
```
Then the curves can be cropped to the desired interval of distances $[r_{min}, r_{max}]$
```{r saplings_csr_L2}
curve_set <- crop_curves(env, r_min = rmin, r_max = rmax)
```
And a global envelope test done by means of the global_envelope_test function (`type="rank"` and larger `nsim` was used in Myllymaki et al., 2017, S4):
```{r saplings_csr_L3}
res <- global_envelope_test(curve_set, type="erl")
plot(res, ylab=expression(italic(hat(L)(r)-r)))
```

The CSR hypothesis is clearly rejected and the rank envelope indicates clear
clustering of saplings. As a next step, we explore the Matern cluster process as a null model.
This is a composite hypothesis.

First we fit the Matern cluster process to the pattern. Here we use the minimum contrast estimation with the K-funcion (the pair correction function can be chosen by setting `statistic="pcf`).
```{r saplings_matclust}
fitted_model <- kppm(saplings~1, clusters = "MatClust", statistic="K")
summary(fitted_model)
```

Next step is to perform the adjusted directional quantile global envelope test using the centred L function.
(For the rank envelope test, choose `type = "rank"` instead and increase `nsim`.)
```{r saplings_matclust2}
nsim <- 19 # 19 just for experimenting with the code!!
#nsim <- 499 # 499 is ok for type = 'qdir' (takes > 1 h)
adjenvL <- GET.composite(X = fitted_model,
                      fun="Lest", correction="translate",
                      transform = expression(.-r), r=r,
                      type = "qdir", nsim = nsim, nsimsub = nsim,
                      r_min=rmin, r_max=rmax, verbose=FALSE)
# Plot the test result
plot(adjenvL, ylab=expression(italic(L(r)-r)))
```

From the test with the centred L function, it appears that the Matern cluster model would be
a reasonable model for the saplings pattern.
To further explore the goodness-of-fit of the Matern cluster process, test the
model with the J function:
This takes quite some time if nsim is reasonably large.
```{r saplings_matclust3}
adjenvJ <- GET.composite(X = fitted_model,
                        fun="Jest", correction="none", r=rJ,
                        type = "qdir", nsim = nsim, nsimsub = nsim,
                        r_min=rminJ, r_max=rmaxJ, verbose=FALSE)
# Plot the test result
plot(adjenvJ, ylab=expression(italic(J(r))))
```
Thus, it appears that the Matern cluster process is not adequate for the saplings data.
The Matern cluster model might be interpreted as a regeneration process in circular gaps
between large trees. However, it is possible that the gap openings in the forest were not exactly
circular, thereby leading to the rejection of the model by the J-function.

It is also possible to test the fit of the Matern cluster process simultaneously by the two test functions:
```{r saplings_matclust4}
adjenvLJ <- GET.composite(X = fitted_model,
                      testfuns = list(L = list(fun="Lest", correction="translate",
                                          transform = expression(.-r), r=r),
                                      J = list(fun="Jest", correction="none", r=rJ)),
                      type = "erl", nsim = nsim, nsimsub = nsim,
                      r_min=c(rmin, rminJ), r_max=c(rmax, rmaxJ),
                      save.cons.envelope=TRUE, verbose=FALSE)
plot(adjenvLJ)
```
