---
title: "GET: Point patterns"
author: "Mari MyllymÃ¤ki"
date: "`r Sys.Date()`"
output:
  pdf_document:
    toc: TRUE
bibliography: GETbibfile.bib
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{GET: Point patterns}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE
)
```

This vignette gives examples of the use of global envelopes for the analysis of spatial point patterns.
The examples utilize the R [@R2020] package spatstat [@spatstat2015] in addition to the GET package [@MyllymakiMrkvicka2019]. The envelope plots are produced by the use of the ggplot2 package [@Wickham2016]
```{r setup}
library("GET")
library("spatstat")
```

# General workflow of the tests

## Utilizing the spatstat package

In general, it is useful in the point pattern analysis utilize the spatstat package. The workflow utilizing spatstat with the GET package is typically the following:

Say we have a point pattern, for which we would like to test a hypothesis, as a ppp object of spatstat. E.g.
```{r wf1}
X <- spruces
X
```

1. To test complete spatial randomness (CSR):

* Use the function envelope of spatstat to create nsim simulations
under CSR and to calculate the functions you want.
Important: use the option 'savefuns=TRUE' and
specify the number of simulations nsim.
See the help documentation in the spatstat package
for possible test functions (if the argument fun is not given, the function Kest is used,
i.e. an estimator of the K function).

Making 999 simulations of CSR and estimating K-function for each of them and data
(the argument simulate specifies how to perform simulations under CSR):
```{r wf2}
env <- envelope(X, nsim=999, savefuns=TRUE,
                simulate=expression(runifpoint(ex=X)))
```

* Perform the test

```{r wf3}
res <- global_envelope_test(env)
```

* Plot the result

```{r wf4, fig.width=4, fig.height=4}
plot(res)
```

2. To test a goodness-of-fit of a parametric model (composite hypothesis case):

* Fit the model to your data by means of the function ppm or kppm of spatstat.
See the help documentation for possible models.
* Use the function GET.composite to create nsim simulations
from the fitted model, to calculate the functions you want,
and to make an adjusted global envelope test.
See the example below.
* Plot the result.

More detailed examples are given below.

## The workflow when using your own programs for simulations

* (Fit the model and) Create nsim simulations from the (fitted) null model.
* Calculate the functions T_1(r), T_2(r), ..., T_{nsim+1}(r).
* Use create_curve_set to create a curve_set object from the functions T_i(r), i=1,...,s+1.
* Perform the test and plot the result

See example in the help file of the global_envelope_test function.

# Testing simple hypotheses for point patterns and marked point patterns

## Testing complete spatial randomness (CSR)

Let us illustrate the CSR for the spruces data set from the R library spatstat.
```{r spruces}
X <- unmark(spruces)
plot(X)
```

Below the function envelope of the spatstat package is used to generate point patterns under CSR (specified in the argument 'simulate') and to calculate the centred L-functions (specified below by the arguments fun, correction and transform), which are used here as the test functions.

```{r csr}
nsim <- 1999 # Number of simulations
env <- envelope(X, fun="Lest", nsim=nsim,
                savefuns=TRUE, # save the functions
                correction="translate", # edge correction for L
                transform = expression(.-r), # centering
                simulate=expression(runifpoint(ex=X)), # Simulate CSR
                verbose=FALSE)
# The rank envelope test (ERL)
res <- global_envelope_test(env, type="erl")
# Plot the result
plot(res)
```

It is possible to cut the functions to an interval of distances $[r_{min}, r_{max}]$ (at the same time creating a curve_set from 'env') and perform the test on the functions on this interval only:
```{r csr_cont, fig.width=4, fig.height=4}
cset <- crop_curves(env, r_min=1, r_max=7)
# Do the rank envelope test (erl)
res <- global_envelope_test(cset, type="erl")
plot(res, ylab=expression(italic(hat(L)(r)-r)))
```

## Testing random labeling of marks

Let know the studied marked point pattern be the spruces data with marks:
```{r spruces_mpp}
mpp <- spruces
plot(mpp)
```

As in the CSR test, to perform the test of random labelling hypothesis, first the envelope function of spatstat can be used to generate simulations and calculate the test function $T(r)$ for the data pattern (mpp) and each simulation.
Below the estimator of the mark-weighted L function, $L_{mm}(r)$, with translational edge correction is used as the test function. The argumen 'simulate' specifies the simulations under the random labeling, i.e., simple permutation of the marks.
```{r randomlabeling}
nsim <- 1999 # Number of simulations
env <- envelope(mpp, fun=Kmark, nsim = nsim, f=function(m1, m2) { m1*m2 },
                correction="translate", returnL=TRUE,
                simulate=expression(rlabel(mpp, permute=TRUE)), # Permute the marks
                savefuns=TRUE, # Save the functions
                verbose=FALSE)
```
Thereafter, the curves can be cropped to the desired r-interval and centered by the mean of the simulated functions for better visualization, before making the test.
```{r randomlabeling_cont, fig.width=4, fig.height=4}
# Crop curves to desired r-interval
curve_set <- crop_curves(env, r_min=1.5, r_max=9.5)
# Center the functions, i.e. take \hat{L}_mm(r)-the mean of simulated functions.
curve_set <- residual(curve_set)
# The global envelope test
res <- global_envelope_test(curve_set)
plot(res, ylab=expression(italic(L[mm](r)-L(r))))
```


## A combined global envelope test

Sometimes it may be desired to base the test on several test functions [@MrkvickaEtal2017].
Below it is illustrated how the CSR can be tested simultaneously by means of L, F, G and J functions for the saplings data set available in the GET library.


```{r combined, fig.width=5, fig.height=5}
#================================
data(saplings)
X <- saplings

nsim <- 499 # Number of simulations

# Specify distances for different test functions
n <- 500 # the number of r-values
rmin <- 0; rmax <- 20; rstep <- (rmax-rmin)/n
rminJ <- 0; rmaxJ <- 8; rstepJ <- (rmaxJ-rminJ)/n
r <- seq(0, rmax, by=rstep)    # r-distances for Lest
rJ <- seq(0, rmaxJ, by=rstepJ) # r-distances for Fest, Gest, Jest

# Perform simulations of CSR and calculate the L-functions
env_L <- envelope(X, nsim=nsim,
                simulate=expression(runifpoint(ex=X)),
                fun="Lest", correction="translate",
                transform=expression(.-r), # Take the L(r)-r function instead of L(r)
                r=r,                       # Specify the distance vector
                savefuns=TRUE,             # Save the estimated functions
                savepatterns=TRUE,         # Save the simulated patterns
                verbose=FALSE)
# Take the simulations from the returned object
simulations <- attr(env_L, "simpatterns")
# Then calculate the other test functions F, G, J for each simulated pattern
env_F <- envelope(X, nsim=nsim,
                simulate=simulations,
                fun="Fest", correction="Kaplan", r=rJ,
                savefuns=TRUE, verbose=FALSE)
env_G <- envelope(X, nsim=nsim,
                simulate=simulations,
                fun="Gest", correction="km", r=rJ,
                savefuns=TRUE, verbose=FALSE)
env_J <- envelope(X, nsim=nsim,
                simulate=simulations,
                fun="Jest", correction="none", r=rJ,
                savefuns=TRUE, verbose=FALSE)

# Crop the curves to the desired r-interval I
curve_set_L <- crop_curves(env_L, r_min=rmin, r_max=rmax)
curve_set_F <- crop_curves(env_F, r_min=rminJ, r_max=rmaxJ)
curve_set_G <- crop_curves(env_G, r_min=rminJ, r_max=rmaxJ)
curve_set_J <- crop_curves(env_J, r_min=rminJ, r_max=rmaxJ)

res <- global_envelope_test(curve_sets=list(curve_set_L, curve_set_F,
                                          curve_set_G, curve_set_J))
plot(res, labels=c("L(r)-r", "F(r)", "G(r)", "J(r)"))
```

# A one-stage goodness-of-fit test (typically conservative!)

It is possible to perform a one-stage goodness-of-fit test for point process models as follows, accepting that the test may be conservative (or liberal). In literature, it has been recommended that the tests may be used if the test function is not closely related to the estimation procedure that was used to fit the model. However, GET.composite can be used for adjusted tests, see the help file of this function and an example below.

```{r gof, fig.width=4, fig.height=4}
X <- unmark(spruces)
# Minimum distance between points in the pattern
min(nndist(X))
# Fit a model
fittedmodel <- ppm(X, interaction=Hardcore(hc=1)) # Hardcore process

# Simulating Gibbs process by 'envelope' is slow, because it uses the MCMC algorithm
#env <- envelope(fittedmodel, fun="Jest", nsim=999, savefuns=TRUE,
#                correction="none", r=seq(0, 4, length=500))

# Using direct algorihm can be faster, because the perfect simulation is used here.
simulations <- NULL
nsim <- 999 # Number of simulations
for(j in 1:nsim) {
   simulations[[j]] <- rHardcore(beta=exp(fittedmodel$coef[1]),
                                 R=fittedmodel$interaction$par$hc,
                                 W=X$window)
   if(j%%10==0) cat(j, "...", sep="")
}
env <- envelope(X, simulate=simulations, fun="Jest", nsim=length(simulations),
                savefuns=TRUE, correction="none", r=seq(0, 4, length=500), verbose=FALSE)
curve_set <- crop_curves(env, r_min=1, r_max=3.5)
res <- global_envelope_test(curve_set, type="erl"); plot(res, ylab=expression(italic(J(r))))
```

Note: Conditioning the Gibbs hard-core model on the number of points, the only parameter in
the hard-core model is the hard-core distance. It is possible to fix the hard-core distance, e.g.
to the minimum distance between two points in the data, and then the test of
the hard-core model with fixed hard-core distance is simple (no parameters involved), and thus exact.
This example is given in @MyllymakiEtal2017 and it is possible to prepare simulations for this case utilizing
the function rmh of the spatstat package.
In the above example conditioning on the number of points was not employed.

# Adjusted global envelope test for composite hypotheses

Let us test the fit of a Matern cluster process for the sapling data as an example of a composite hypothesis test.
The adjusted test of the GET package is described in Section 2.3 of @MyllymakiMrkvicka2019. The procedure was suggested by @BaddeleyEtal2017 and extended for global envelopes in GET [@MyllymakiMrkvicka2019].

```{r saplings}
data(saplings)
plot(saplings)
```

First define the r-distances and number of simulations. Here we set the number of simulations just to 19, for fast exploration of the code, but for serious analysis we recommend at least 499 simulations.

```{r adjusted_init}
rmin <- 0.3; rmax <- 10; rstep <- (rmax-rmin)/500
r <- seq(0, rmax, by=rstep)
nsim <- 19 # Increase nsim for serious analysis!
```

The Matern cluster process can be fitted to the pattern using the ppm function of spatstat. This utilizes minimum contrast estimation with the K-function.
```{r adjusted_fit}
M1 <- kppm(saplings~1, clusters = "MatClust", statistic="K")
M1
```
Then the adjusted global area rank envelope test can be performed using the function GET.composite. Below we use the centred L(r) function as the test function. The argument 'type' specifies the global envelope test, see the help file of the global_envelope_test function.
```{r adjusted_test, fig.width=4, fig.height=4}
adjenvL <- GET.composite(X = M1, nsim = nsim,
            testfuns = list(L = list(fun="Lest", correction="translate",
                           transform = expression(.-r), r=r)), # passed to envelope
            type = "area", r_min=rmin, r_max=rmax, verbose=FALSE)
plot(adjenvL)
```

# Testing global and local dependence of point patterns on covariates

The function GET.spatialF performs the one-stage global envelope tests based on spatial F- and S-statistics [@MyllymakiEtal2020] to explore the effects of covariates in parametric point process models.

Let us look at a simple example of tropical rain forest trees.
```{r spatialF}
data(bei)
```

Let us study the effect of gradient on the intensity of the trees. We define the full model including this interesting covariate and the reduced model, which is otherwise the same as the full model, but the interesting covariate is excluded. Further the function fitppm defines how the (full or reduced) model can be fitted to the point pattern.
```{r spatialF_bei, fig.width=6, fig.height=3}
fullmodel <- ~ grad
reducedmodel <- ~ 1
fitppm <- function(X, model, covariates) {
  ppm(X, model, covariates=covariates)
}

nsim <- 19 # Increase nsim for serious analysis!
res <- GET.spatialF(bei, fullmodel, reducedmodel, fitppm, bei.extra, nsim)

plot(res$F)
plot(res$S)
```

Another example is the test of the effect of elevation on the point pattern of lightnings.
```{r spatialF_ff, fig.width=6, fig.height=3}
# Example of forest fires
data("clmfires")
# Choose the locations of the lightnings in years 2004-2007:
pp.lightning <- unmark(subset(clmfires, cause == "lightning" &
                 date >= "2004-01-01" & date < "2008-01-01"))

covariates <- clmfires.extra$clmcov100
covariates$forest <- covariates$landuse == "conifer" | covariates$landuse == "denseforest" |
                      covariates$landuse == "mixedforest"

fullmodel <- ~ elevation + landuse
reducedmodel <- ~ landuse
nsim <- 19 # Increase nsim for serious analysis!
res <- GET.spatialF(pp.lightning, fullmodel, reducedmodel, fitppm, covariates, nsim)
plot(res$F)
plot(res$S)
```

Above only the inhomogeneous Poisson process was used as the model. Examples of the fitfun functions for clustered and regular processes are:
```{r spatialF_extra}
# fitfun for the log Gaussian Cox Process with exponential covariance function
fitLGCPexp <- function(X, model, covariates) {
  kppm(X, model, clusters="LGCP", model="exponential", covariates=covariates)
}
# fitfun for the hardcore process with hardcore radius 0.01
fitHardcore <- function(X, model, covariates) {
  ppm(X, model, interaction=Hardcore(0.01), covariates = covariates)
}
```

# An example analysis of the saplings data set

This is the example of @MyllymakiEtal2017 [Supplement S4].

The saplings data set is available at the GET package.

```{r saplings_data}
data(saplings)
```

First choose the r-distances for L (r) and J (rJ) functions, respectively.

```{r saplings_init}
nr <- 500
rmin <- 0.3; rminJ <- 0.3
rmax <- 10; rmaxJ <- 6
rstep <- (rmax-rmin)/nr; rstepJ <- (rmaxJ-rminJ)/nr
r <- seq(0, rmax, by=rstep)
rJ <- seq(0, rmaxJ, by=rstepJ)
```

## The CSR test based on the L(r)-r function

Note: CSR is simulated by fixing the number of points and generating nsim simulations
from the binomial process, i.e. we deal with a simple hypothesis.

First, the envelope function of the spatstat package can be used to generate nsim simulations under CSR and
to calculate the centred L function for the data and each simulation.
```{r saplings_csr_L}
nsim <- 999 # Number of simulations
env <- envelope(saplings, nsim=nsim,
    simulate=expression(runifpoint(saplings$n, win=saplings$window)), # Simulate CSR
    fun="Lest", correction="translate", # T(r) = estimator of L with translational edge correction
    transform = expression(.-r),        # Take the L(r)-r function instead of L(r)
    r=r,                                # Specify the distance vector
    savefuns=TRUE)                      # Save the estimated functions
```
Then the curves can be cropped to the desired interval of distances $[r_{min}, r_{max}]$
```{r saplings_csr_L2}
curve_set <- crop_curves(env, r_min = rmin, r_max = rmax)
```
And a global envelope test done by means of the global_envelope_test function (`type="rank"` and larger `nsim` was used in @MyllymakiEtal2017 [S4]:
```{r saplings_csr_L3}
res <- global_envelope_test(curve_set, type="erl")
plot(res, ylab=expression(italic(hat(L)(r)-r)))
```

The CSR hypothesis is clearly rejected and the rank envelope indicates clear
clustering of saplings. As a next step, we explore the Matern cluster process as a null model.
This is a composite hypothesis.

## Testing the fit of a Matern cluster process

First we fit the Matern cluster process to the pattern. Here we use the minimum contrast estimation with the K-funcion (the pair correction function can be chosen by setting `statistic="pcf`).
```{r saplings_matclust}
fitted_model <- kppm(saplings~1, clusters = "MatClust", statistic="K")
```

Next step is to perform the adjusted directional quantile global envelope test using the centred L function.
(For the rank envelope test, choose `type = "rank"` instead and increase `nsim`.)
```{r saplings_matclust2}
nsim <- 19 # 19 just for experimenting with the code!!
#nsim <- 499 # 499 is ok for type = 'qdir' (takes > 1 h)
adjenvL <- GET.composite(X = fitted_model,
                      fun="Lest", correction="translate",
                      transform = expression(.-r), r=r,
                      type = "qdir", nsim = nsim, nsimsub = nsim,
                      r_min=rmin, r_max=rmax, verbose=FALSE)
# Plot the test result
plot(adjenvL, ylab=expression(italic(L(r)-r)))
```

From the test with the centred L function, it appears that the Matern cluster model would be
a reasonable model for the saplings pattern.
To further explore the goodness-of-fit of the Matern cluster process, test the
model with the J function:
This takes quite some time if nsim is reasonably large.
```{r saplings_matclust3}
adjenvJ <- GET.composite(X = fitted_model,
                        fun="Jest", correction="none", r=rJ,
                        type = "qdir", nsim = nsim, nsimsub = nsim,
                        r_min=rminJ, r_max=rmaxJ, verbose=FALSE)
# Plot the test result
plot(adjenvJ, ylab=expression(italic(J(r))))
```

Thus, it appears that the Matern cluster process is not adequate for the saplings data.
The Matern cluster model might be interpreted as a regeneration process in circular gaps
between large trees. However, it is possible that the gap openings in the forest were not exactly
circular, thereby leading to the rejection of the model by the J-function.

It is also possible to test the fit of the Matern cluster process simultaneously by the two test functions:
```{r saplings_matclust4, fig.width=5, fig.height=3}
adjenvLJ <- GET.composite(X = fitted_model,
                      testfuns = list(L = list(fun="Lest", correction="translate",
                                          transform = expression(.-r), r=r),
                                      J = list(fun="Jest", correction="none", r=rJ)),
                      type = "erl", nsim = nsim, nsimsub = nsim,
                      r_min=c(rmin, rminJ), r_max=c(rmax, rmaxJ),
                      save.cons.envelope=TRUE, verbose=FALSE)
plot(adjenvLJ)
```

# References
