---
title: "Point patterns"
author: "Mari Myllymäki"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{pointpatterns}
  %\VignetteEngine{knitr::knitr}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


These examples utilize the R package spatstat in addition to the GET package.
```{r setup}
library("GET")
library("spatstat")
```

# Testing simple hypotheses for point patterns and marked point patterns

## Testing complete spatial randomness (CSR)

Let us illustrate the CSR for the spruces data set from the R library spatstat.
```{r spruces}
X <- unmark(spruces)
plot(X)
```

Below we use the function envelope of the spatstat package to generate point patterns under CSR (specified in the argument 'simulate') and to calculate the centred L-functions (specified below by the arguments fun, correction and transform) that we utilize here as the test functions.

```{r csr}
nsim <- 1999 # Number of simulations
env <- envelope(X, fun="Lest", nsim=nsim,
                savefuns=TRUE, # save the functions
                correction="translate", # edge correction for L
                transform = expression(.-r), # centering
                simulate=expression(runifpoint(ex=X)), # Simulate CSR
                verbose=FALSE)
# The rank envelope test (ERL)
res <- global_envelope_test(env, type="erl")
# Plot the result
plot(res)
```

It is possible to cut the functions to an interval of distances [r_min, r_max] (at the same time create a curve_set from 'env') and perform the test on the functions on this interval only:
```{r csr_cont}
cset <- crop_curves(env, r_min=1, r_max=7)
# Do the rank envelope test (erl)
res <- global_envelope_test(cset, type="erl")
plot(res, ylab=expression(italic(L(r)-r)))
```

## Testing random labeling of marks

Let know the studied marked point pattern be the spruces data with marks:
```{r spruces_mpp}
mpp <- spruces
plot(mpp)
```

As in the CSR test, to perform the test of random labelling hypothesis, first the envelope function of spatstat can be used to generate simulations and calculate the test function T(r) for the data pattern (mpp) and each simulation.
Below we use as the test function the estimator of the mark-weighted L function, L_mm(r), with translational edge correction. The argumen 'simulate' specifies the simulations under the random labeling, i.e. simple permutation of the marks.
```{r randomlabeling}
nsim <- 1999 # Number of simulations
env <- envelope(mpp, fun=Kmark, nsim = nsim, f=function(m1, m2) { m1*m2 },
                correction="translate", returnL=TRUE,
                simulate=expression(rlabel(mpp, permute=TRUE)), # Permute the marks
                savefuns=TRUE, # Save the functions
                verbose=FALSE)
```
Thereafter, the curves can be cropped to the desired r-interval and centered by the mean of the simulated functions for better visualization, before making the test.
```{r randomlabeling_cont}
# Crop curves to desired r-interval
curve_set <- crop_curves(env, r_min=1.5, r_max=9.5)
# Center the functions, i.e. take \hat{L}_mm(r)-the mean of simulated functions.
curve_set <- residual(curve_set)
# The global envelope test
res <- global_envelope_test(curve_set)
plot(res, ylab=expression(italic(L[mm](r)-L(r))))
```


## A combined global envelope test

Sometimes it may be desired to base the test on several test functions. 
Below it is illustrated how the CSR can be tested simultaneously by means of L, F, G and J functions for the saplings data set available in the GET library.


```{r combined}
#================================
data(saplings)
X <- saplings

nsim <- 499 # Number of simulations

# Specify distances for different test functions
n <- 500 # the number of r-values
rmin <- 0; rmax <- 20; rstep <- (rmax-rmin)/n
rminJ <- 0; rmaxJ <- 8; rstepJ <- (rmaxJ-rminJ)/n
r <- seq(0, rmax, by=rstep)    # r-distances for Lest
rJ <- seq(0, rmaxJ, by=rstepJ) # r-distances for Fest, Gest, Jest

# Perform simulations of CSR and calculate the L-functions
env_L <- envelope(X, nsim=nsim,
                simulate=expression(runifpoint(ex=X)),
                fun="Lest", correction="translate",
                transform=expression(.-r), # Take the L(r)-r function instead of L(r)
                r=r,                       # Specify the distance vector
                savefuns=TRUE,             # Save the estimated functions
                savepatterns=TRUE,         # Save the simulated patterns
                verbose=FALSE)
# Take the simulations from the returned object
simulations <- attr(env_L, "simpatterns")
# Then calculate the other test functions F, G, J for each simulated pattern
env_F <- envelope(X, nsim=nsim,
                simulate=simulations,
                fun="Fest", correction="Kaplan", r=rJ,
                savefuns=TRUE, verbose=FALSE)
env_G <- envelope(X, nsim=nsim,
                simulate=simulations,
                fun="Gest", correction="km", r=rJ,
                savefuns=TRUE, verbose=FALSE)
env_J <- envelope(X, nsim=nsim,
                simulate=simulations,
                fun="Jest", correction="none", r=rJ,
                savefuns=TRUE, verbose=FALSE)

# Crop the curves to the desired r-interval I
curve_set_L <- crop_curves(env_L, r_min=rmin, r_max=rmax)
curve_set_F <- crop_curves(env_F, r_min=rminJ, r_max=rmaxJ)
curve_set_G <- crop_curves(env_G, r_min=rminJ, r_max=rmaxJ)
curve_set_J <- crop_curves(env_J, r_min=rminJ, r_max=rmaxJ)

res <- global_envelope_test(curve_sets=list(curve_set_L, curve_set_F,
                                          curve_set_G, curve_set_J))
plot(res, labels=c("L(r)-r", "F(r)", "G(r)", "J(r)"))
```


## Goodness-of-fit test (typically conservative)

It is possible to perform a one-stage goodness-of-fit test for point process models as follows, accepting that the test may be conservative (or liberal). In literature, it has been recommended that the tests may be used if the test function is not closely related to the estimation procedure that was used to fit the model. However, GET.composite can be used for adjusted tests, see the help file of this function and an example below.

```{r gof}
X <- unmark(spruces)
# Minimum distance between points in the pattern
min(nndist(X))
# Fit a model
fittedmodel <- ppm(X, interaction=Hardcore(hc=1)) # Hardcore process

# Simulating Gibbs process by 'envelope' is slow, because it uses the MCMC algorithm
#env <- envelope(fittedmodel, fun="Jest", nsim=999, savefuns=TRUE,
#                correction="none", r=seq(0, 4, length=500))

# Using direct algorihm can be faster, because the perfect simulation is used here.
simulations <- NULL
nsim <- 999 # Number of simulations
for(j in 1:nsim) {
   simulations[[j]] <- rHardcore(beta=exp(fittedmodel$coef[1]),
                                 R=fittedmodel$interaction$par$hc,
                                 W=X$window)
   if(j%%10==0) cat(j, "...", sep="")
}
env <- envelope(X, simulate=simulations, fun="Jest", nsim=length(simulations),
                savefuns=TRUE, correction="none", r=seq(0, 4, length=500), verbose=FALSE)
curve_set <- crop_curves(env, r_min=1, r_max=3.5)
res <- global_envelope_test(curve_set, type="erl"); plot(res, ylab=expression(italic(J(r))))
```


## Adjusted global envelope test

Let us test the fit of a Matern cluster process for the sapling data as an example of a composite hypothesis test.

```{r saplings}
data(saplings)
plot(saplings)
```

First define the r-distances and number of simulations. Here we set the number of simulations just to 19, for fast exploration of the code, but for serious analysis we recommend at least 499 simulations.

```{r adjusted_init}
rmin <- 0.3; rmax <- 10; rstep <- (rmax-rmin)/500
r <- seq(0, rmax, by=rstep)
nsim <- 19 # Increase nsim for serious analysis!
```

The Matern cluster process can be fitted to the pattern using the ppm function of spatstat. This utilizes minimum contrast estimation with the K-function.
```{r adjusted_fit}
M1 <- kppm(saplings~1, clusters = "MatClust", statistic="K")
M1
```
Then the adjusted global area rank envelope test can be performed using the function GET.composite. Below we use the centred L(r) function as the test function. The argument 'type' specifies the global envelope test, see ?global_envelope_test.
```{r adjusted_test}
adjenvL <- GET.composite(X = M1, nsim = nsim,
            testfuns = list(L = list(fun="Lest", correction="translate",
                           transform = expression(.-r), r=r)), # passed to envelope
            type = "area", r_min=rmin, r_max=rmax, verbose=FALSE)
plot(adjenvL)
```

## Testing global and local dependence of point patterns on covariates

The function GET.spatialF performs the one-stage global envelope tests based on spatial F- and S-statistics that were proposed by Myllymäki et al. (2020) to explore the effects of covariates in parametric point process models.

Let us look at a simple example of tropical rain forest trees.
```{r spatialF}
data(bei)
```

Let us study the effect of gradient on the intensity of the trees. We define the full model including this interesting covariate and the reduced model, which is otherwise the same as the full model, but the interesting covariate is excluded. Further the function fitppm defines how the (full or reduced) model can be fitted to the point pattern.
```{r spatialF_bei}
fullmodel <- ~ grad
reducedmodel <- ~ 1
fitppm <- function(X, model, covariates) {
  ppm(X, model, covariates=covariates)
}

nsim <- 19 # Increase nsim for serious analysis!
res <- GET.spatialF(bei, fullmodel, reducedmodel, fitppm, bei.extra, nsim)

plot(res$F)
plot(res$S)
```

Another example is the test of the effect of elevation on the point pattern of lightnings.
```{r spatialF_ff}
# Example of forest fires
data("clmfires")
# Choose the locations of the lightnings in years 2004-2007:
pp.lightning <- unmark(subset(clmfires, cause == "lightning" &
                 date >= "2004-01-01" & date < "2008-01-01"))

covariates <- clmfires.extra$clmcov100
covariates$forest <- covariates$landuse == "conifer" | covariates$landuse == "denseforest" |
                      covariates$landuse == "mixedforest"

fullmodel <- ~ elevation + landuse
reducedmodel <- ~ landuse
nsim <- 19 # Increase nsim for serious analysis!
res <- GET.spatialF(pp.lightning, fullmodel, reducedmodel, fitppm, covariates, nsim)
plot(res$F)
plot(res$S)
```

Above only the inhomogeneous Poisson process was used as the model. Examples of the fitfun functions for clustered and regular processes are:
```{r spatialF_extra}
# fitfun for the log Gaussian Cox Process with exponential covariance function
fitLGCPexp <- function(X, model, covariates) {
  kppm(X, model, clusters="LGCP", model="exponential", covariates=covariates)
}
# fitfun for the hardcore process with hardcore radius 0.01
fitHardcore <- function(X, model, covariates) {
  ppm(X, model, interaction=Hardcore(0.01), covariates = covariates)
}
```
