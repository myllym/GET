% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/envelopes.r
\name{rank_envelope}
\alias{rank_envelope}
\title{The rank envelope test}
\usage{
rank_envelope(curve_set, alpha = 0.05, savedevs = FALSE,
  alternative = c("two.sided", "less", "greater"), lexo = FALSE, ties)
}
\arguments{
\item{curve_set}{A curve_set (see \code{\link{create_curve_set}}) or an \code{\link[spatstat]{envelope}}
object. If an envelope object is given, it must contain the summary
functions from the simulated patterns which can be achieved by setting
savefuns = TRUE when calling \code{\link[spatstat]{envelope}}.}

\item{alpha}{The significance level. The 100(1-alpha)\% global envelope will be calculated.}

\item{savedevs}{Logical. Should the global rank values k_i, i=1,...,nsim+1 be returned? Default: FALSE.}

\item{alternative}{A character string specifying the alternative hypothesis. Must be one of the following:
"two.sided" (default), "less" or "greater".}

\item{lexo}{Logical, whether or not to use rank count ordering for calculation of the p-value. See details.}

\item{ties}{Ties method to be passed to \code{\link{estimate_p_value}}. Used to obtain
a point estimate for the p-value. The default point estimate is the mid-rank p-value.}
}
\value{
An object of class "envelope_test", "envelope" and "fv" (see \code{\link[spatstat]{fv.object}}),
which can be printed and plotted directly.

Essentially a data frame containing columns
\itemize{
\item r = the vector of values of the argument r at which the test was made
\item obs = values of the test function for the data point pattern
\item lo = the lower envelope based on the simulated functions
\item hi = the upper envelope based on the simulated functions
\item central = If the curve_set (or envelope object) contains a component 'theo',
      then this function is used as the central curve and returned in this component.
      Otherwise, the central_curve is the mean of the test functions T_i(r), i=2, ..., s+1.
      Used for visualization only.
}
Additionally, the return value has attributes
\itemize{
  \item method = The name of the envelope test ("Rank envelope test" for the rank envelope test)
  \item alternative = The alternative specified in the function call.
  \item p = A point estimate for the p-value (default is the mid-rank p-value).
  \item p_interval = The p-value interval [p_liberal, p_conservative].
  \item ties = As the argument \code{ties}.
  \item k_alpha = The value of k corresponding to the 100(1-alpha)\% global envelope.
  \item k = Global rank values (k[1] is the value for the data pattern). Returned only if savedevs = TRUE.
  \item call = The call of the function.
}
and a punch of attributes for the "fv" object type.
}
\description{
The rank envelope test, p-value and global envelope
}
\details{
The rank envelope test is a completely non-parametric test, which provides
the 100(1-alpha)\% global envelope for the chosen test function T(r) on
the chosen interval of distances and a p-value interval given by the most
liberal and the most conservative p-value estimate.

Given a \code{curve_set} (or an \code{\link[spatstat]{envelope}}) object,
which contains both the data curve T_1(r) and the simulated curves T_2(r),...T_(s+1)(r),
the test is carried out as follows.

For each curve in the curve_set, both the data curve and the simulations,
the global rank measure R is determined. If savedevs = TRUE, then the
global rank values R_1, R_2, ..., R_(s+1) are returned in the component 'k',
where k[1] is the value for the data.

Based on R_i, i=1, ..., s+1, the p-interval is calculated. This interval is
by default plotted for the object returned by the rank_envelope function.
Also a single p-value is calculated and returned in component 'p'. By default
this p-value is the mid-rank p-value, but another option can be used by specifying
\code{ties} argument which is passed to \code{\link{estimate_p_value}}. For
options see \code{\link{estimate_p_value}}.

The 100(1-alpha)\% global envelope is given by the 'k_alpha'th lower and
upper envelope. For details see Myllymäki et al. (2017).

The above holds for p-value calculation if \code{lexo == FALSE} and then the test
corresponds to the rank envelope test by Myllymaki et. al (2013). If \code{lexo == TRUE},
then all the pointwise ranks are used to rank the curves by rank count ordering (Myllymäki et al., 2017)
and the single p-value in \code{p} is the p-value based on the rank count ordering.

The rank count ordering test allows in principle a lower number of simulations to be used,
but then the test may no longer be usable as a graphical test.
}
\examples{

## Testing complete spatial randomness (CSR)
#-------------------------------------------
require(spatstat)
pp <- unmark(spruces)
# Generate nsim simulations under CSR, calculate L-function for the data and simulations
env <- envelope(pp, fun="Lest", nsim=2499, savefuns=TRUE, correction="translate")
# The rank envelope test
res <- rank_envelope(env)
# Plot the result.
# - The central curve is now obtained from env[['theo']], which is the
# value of the L-function under the null hypothesis (L(r) = r).
plot(res)
# or (requires R library ggplot2)
plot(res, plot_style="ggplot2")

## Advanced use:
# Choose the interval of distances [r_min, r_max] (at the same time create a curve_set from 'env')
curve_set <- crop_curves(env, r_min = 1, r_max = 7)
# For better visualisation, take the L(r)-r function
curve_set <- residual(curve_set, use_theo = TRUE)
# Do the rank envelope test
res <- rank_envelope(curve_set); plot(res, plot_style="ggplot2")

## Random labeling test
#----------------------
# requires library 'marksummary'
mpp <- spruces
# 1) Perform simulations under the random labelling hypothesis and calculate
# the test function T(r) for the data pattern (mpp) and each simulation.
# The command below specifies that the test function is T(r) = \\hat{L}_m(r),
# which is an estimator of the mark-weighted L function, L_m(r),
# with translational edge correction (default).
# The random_labelling function returns the centred functions \\hat{L}_m(r)-T_0(r),
# where T_0(r) = \\hat{L}(r) is the unmarked L function.
curve_set <- random_labelling(mpp, mtf_name = 'm', nsim=2499, r_min=1.5, r_max=9.5)
# 2) Do the rank envelope test
res <- rank_envelope(curve_set)
# 3) Plot the test result
plot(res, plot_style="ggplot2", ylab=expression(italic(L[m](r)-L(r))))

# Make the test using instead the test function T(r) = \\hat{L}_mm(r);
# which is an estimator of the mark-weighted L function, L_mm(r),
# with translational edge correction (default).
curve_set <- random_labelling(mpp, mtf_name = 'mm', nsim=2499, r_min=1.5, r_max=9.5)
res <- rank_envelope(curve_set)
plot(res, plot_style="ggplot2", ylab=expression(italic(L[mm](r)-L(r))))

## Goodness-of-fit test (typically conservative, see dg.global_envelope for adjusted tests)
#-----------------------------------------------
pp <- unmark(spruces)
# Minimum distance between points in the pattern
min(nndist(pp))
# Fit a model
fittedmodel <- ppm(pp, interaction=Hardcore(hc=1)) # Hardcore process

\dontrun{
# Simulating Gibbs process by 'envelope' is slow, because it uses the MCMC algorithm
#env <- envelope(fittedmodel, fun="Jest", nsim=999, savefuns=TRUE,
                 correction="none", r=seq(0, 4, length=500))

# Using direct algorihm can be faster, because the perfect simulation is used here.
simulations <- NULL
for(j in 1:2499) {
   simulations[[j]] <- rHardcore(beta=exp(fittedmodel$coef[1]),
                                 R = fittedmodel$interaction$par$hc,
                                 W = pp$window);
   if(j\%\%10==0) cat(j, "...", sep="")
}
env <- envelope(pp, simulate=simulations, fun="Jest", nsim=length(simulations),
                savefuns=TRUE, correction="none", r=seq(0, 4, length=500))
curve_set <- crop_curves(env, r_min = 1, r_max = 3.5)
res <- rank_envelope(curve_set); plot(res, plot_style="ggplot2")
}

## A test based on a low dimensional random vector
#-------------------------------------------------
# Let us generate some example data.
X <- matrix(c(-1.6,1.6),1,2) # data pattern X=(X_1,X_2)
Y <- mvtnorm::rmvnorm(200,c(0,0),matrix(c(1,0.5,0.5,1),2,2)) # simulations
plot(Y, xlim=c(min(X[,1],Y[,1]), max(X[,1],Y[,1])), ylim=c(min(X[,2],Y[,2]), max(X[,2],Y[,2])))
points(X, col=2)

# Test the null hypothesis is that X is from the distribution of Y's (or if it is an outlier).

# Case 1. The test vector is (X_1, X_2)
cset1 <- create_curve_set(list(r=1:2, obs=as.vector(X), sim_m=t(Y)))
res1 <- rank_envelope(cset1)
plot(res1)

# Case 2. The test vector is (X_1, X_2, (X_1-mean(Y_1))*(X_2-mean(Y_2))).
t3 <- function(x, y) { (x[,1]-mean(y[,1]))*(x[,2]-mean(y[,2])) }
cset2 <- create_curve_set(list(r=1:3, obs=c(X[,1],X[,2],t3(X,Y)), sim_m=rbind(t(Y), t3(Y,Y))))
res2 <- rank_envelope(cset2)
plot(res2)

}
\references{
Myllymäki, M., Mrkvička, T., Seijo, H., Grabarnik, P. (2017). Global envelope tests for spatial point patterns. Journal of the Royal Statistical Society: Series B (Statistical Methodology), 79: 381–404. doi: 10.1111/rssb.12172

Myllymäki, M., Mrkvička, T., Grabarnik, P., Seijo, H. and Hahn, U. Global envelope tests for spatial point patterns. arXiv:1307.0239v4 [stat.ME]

Myllymäki, M., Mrkvička, T., Grabarnik, P., Seijo, H. and Hahn, U. (2013) Global envelope tests for spatial point patterns. arXiv:1307.0239v1 [stat.ME]
}
\seealso{
\code{\link{random_labelling}}, \code{\link{plot.envelope_test}}
}
