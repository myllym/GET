% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/envelopes.r
\name{rank_envelope}
\alias{rank_envelope}
\title{The rank envelope test}
\usage{
rank_envelope(curve_set, alpha = 0.05, savedevs = FALSE,
  alternative = c("two.sided", "less", "greater"), type = "rank",
  lexo = NULL, ties)
}
\arguments{
\item{curve_set}{A curve_set (see \code{\link{create_curve_set}}) or an \code{\link[spatstat]{envelope}}
object. If an envelope object is given, it must contain the summary
functions from the simulated patterns which can be achieved by setting
savefuns = TRUE when calling \code{\link[spatstat]{envelope}}.}

\item{alpha}{The significance level. The 100(1-alpha)\% global envelope will be calculated.}

\item{savedevs}{Logical. Should the global rank values k_i, i=1,...,nsim+1 be returned? Default: FALSE.}

\item{alternative}{A character string specifying the alternative hypothesis. Must be one of the following:
"two.sided" (default), "less" or "greater".}

\item{type}{The type of the global envelope with current options for "rank" and "erl".
If "rank", the global rank envelope accompanied by the p-interval is given (Myllymäki et al., 2017).
If "erl", the global rank envelope based on extreme rank lengths accompanied by the extreme rank
length p-value is given (Myllymäki et al., 2017, Mrkvicka et al., 2018). See details and additional
sections thereafter.}

\item{lexo}{Obsolete. Use type instead.}

\item{ties}{The method to obtain a unique p-value when type = "rank".
Possible values are 'midrank', 'random', 'conservative', 'liberal' and 'erl'.
For 'conservative' the resulting p-value will be the highest possible.
For 'liberal' the p-value will be the lowest possible.
For 'random' the rank of the obs within the tied values is uniformly sampled so that the resulting
p-value is at most the conservative option and at least the liberal option.
For 'midrank' the mid-rank within the tied values is taken.
For 'erl' the extreme rank length p-value is calculated.
The default is 'midrank'.}
}
\value{
An object of class "envelope_test", "envelope" and "fv" (see \code{\link[spatstat]{fv.object}}),
which can be printed and plotted directly.

Essentially a data frame containing columns
\itemize{
\item r = the vector of values of the argument r at which the test was made
\item obs = values of the test function for the data point pattern
\item lo = the lower envelope based on the simulated functions
\item hi = the upper envelope based on the simulated functions
\item central = If the curve_set (or envelope object) contains a component 'theo',
      then this function is used as the central curve and returned in this component.
      Otherwise, the central_curve is the mean of the test functions T_i(r), i=2, ..., s+1.
      Used for visualization only.
}
Additionally, the return value has attributes
\itemize{
  \item method = The name of the envelope test ("Rank envelope test" for the rank envelope test)
  \item alternative = The alternative specified in the function call.
  \item p = A point estimate for the p-value (default is the mid-rank p-value).
  \item p_interval = The p-value interval [p_liberal, p_conservative].
  \item ties = As the argument \code{ties}.
  \item k_alpha = The value of k corresponding to the 100(1-alpha)\% global envelope.
  \item k = Global rank values (for type="rank") or extreme rank lengths (for type="erl").
  k[1] is the value for the data pattern. Returned only if savedevs = TRUE.
  \item call = The call of the function.
}
and a punch of attributes for the "fv" object type, see \code{\link[spatstat]{fv}}.
}
\description{
The rank envelope test, p-values and global envelopes
}
\details{
The rank envelope test is a completely non-parametric test, which provides
the 100(1-alpha)\% global envelope for the chosen test function T(r) on
the chosen interval of distances and associated p-values.

Given a \code{curve_set} (see \code{\link{create_curve_set}} for how to create such an object)
or an \code{\link[spatstat]{envelope}} object,
which contains both the data curve (or function or vector) \eqn{T_1(r)}{T_1(r)} and
the simulated curves \eqn{T_2(r),\dots,T_{s+1}(r)}{T_2(r),...,T_(s+1)(r)},
the test is carried out as described in the following sections that describe
ordering of the functions, p-values and global envelopes.
}
\section{Ranking of the curves}{

First the curves in the curve set are ranked from the most extreme one to the least extreme one
either by using the extreme ranks R_i and/or the extreme rank lengths \eqn{R_i^{\text{erl}}}{Rerl_i}.
The extreme rank is defined as the minimum of pointwise ranks of the curve \eqn{T_i(r)}{T_i(r)},
where the pointwise rank is the rank of the value of the curve for a specific r-value among the
corresponding values of the s other curves such that the lowest ranks correspond to the most extreme
values of the curves. How the pointwise ranks are determined exactly depends on the whether a
one-sided (\code{alternative} is "less" or "greater") or the two-sided test (\code{alternative="two.sided"}) is
chosen, for details see Mrkvička et al. (2017, page 1241) or Mrkvička et al. (2018, page 6).
The extreme ranks can contain many ties, for which reason Myllymäki et al. (2017) proposed the
extreme rank length ordering. Considering the vector of pointwise ordered ranks
\eqn{\mathbf{R}_i}{RP_i} of the ith curve, the extreme rank length measure is equal to
\deqn{R_i^{\text{erl}} = \frac{1}{s+1}\sum_{j=1}^{s+1} \1(\mathbf{R}_j \prec \mathbf{R}_i)}{Rerl_i = \sum_{j=1}^{s} 1(RP_j "<" RP_i) / (s + 1)}
where \eqn{\mathbf{R}_j \prec \mathbf{R}_i}{RP_j "<" RP_i} if and only if
there exists \eqn{n\leq d}{n<=d} such that for the first k, \eqn{k<n}{k<n}, pointwise ordered
ranks of \eqn{\mathbf{R}_j}{RP_j} and \eqn{\mathbf{R}_i}{RP_i} are equal and the n'th rank of
\eqn{\mathbf{R}_j}{RP_j} is smaller than that of \eqn{\mathbf{R}_i}{RP_i}.

For each curve in the curve_set, both the data curve and the simulations,
an above mention measure k is determined. If savedevs = TRUE, then the
measure values \eqn{k_1, k_2, ..., k_{s+1}}{k_1, k_2, ..., k_(s+1)} are
returned in the component 'k', where k[1] is the value for the data.
}

\section{P-values}{

In the case \code{type="rank"}, based on the extreme ranks k_i, i=1, ..., s+1,
the p-interval is calculated. Because the extreme ranks contain ties, there is not just
one p-value. The p-interval is given by the most liberal and the most conservative p-value
estimate. This interval is by default plotted for the object returned by the rank_envelope function.
Also a single p-value is calculated and returned in the attribute \code{p}.
By default this single p-value is the mid-rank p-value, but another option can be used by
specifying \code{ties} argument.

If the case \code{type="erl"}, the (single) p-value based on the extreme rank length ordering
of the functions is calculated and returned in the attribute \code{p}.
}

\section{Global envelope}{

The 100(1-alpha)\% global envelope is provided in addition to the p-values. 
If \code{type="rank"} then the envelope is the global rank envelope proposed by
Myllymäki et al. (2017).
If \code{type="erl"} then the envelope is the global rank envelope based on the
extreme rank length ordering. This envelope is constructed as the convex hull of
the functions which have extreme rank length measure \eqn{R_i^{\text{erl}}}{Rerl_i}
that is larger or equal to the critical \eqn{\alpha}{alpha} level of the extreme rank
length measure (Mrkvička et al., 2018).
}

\section{Number of simulations}{

The extreme rank length ordering test (\code{type="erl"}) allows in principle a lower numbe
of simulations to be used than the test based on extreme ranks (\code{type="rank"}).
However, we recommend some thousands of simulations in any case to achieve a good power
and repeatability of the test.
}

\examples{

## Testing complete spatial randomness (CSR)
#-------------------------------------------
require(spatstat)
pp <- unmark(spruces)
# Generate nsim simulations under CSR, calculate L-function for the data and simulations
env <- envelope(pp, fun="Lest", nsim=2499, savefuns=TRUE, correction="translate")
# The rank envelope test
res <- rank_envelope(env)
# Plot the result.
# - The central curve is now obtained from env[['theo']], which is the
# value of the L-function under the null hypothesis (L(r) = r).
plot(res)
# or (requires R library ggplot2)
plot(res, plot_style="ggplot2")

## Advanced use:
# Choose the interval of distances [r_min, r_max] (at the same time create a curve_set from 'env')
curve_set <- crop_curves(env, r_min = 1, r_max = 7)
# For better visualisation, take the L(r)-r function
curve_set <- residual(curve_set, use_theo = TRUE)
# Do the rank envelope test
res <- rank_envelope(curve_set); plot(res, plot_style="ggplot2")

## Random labeling test
#----------------------
# requires library 'marksummary'
mpp <- spruces
# 1) Perform simulations under the random labelling hypothesis and calculate
# the test function T(r) for the data pattern (mpp) and each simulation.
# The command below specifies that the test function is T(r) = \\hat{L}_m(r),
# which is an estimator of the mark-weighted L function, L_m(r),
# with translational edge correction (default).
# The random_labelling function returns the centred functions \\hat{L}_m(r)-T_0(r),
# where T_0(r) = \\hat{L}(r) is the unmarked L function.
curve_set <- random_labelling(mpp, mtf_name = 'm', nsim=2499, r_min=1.5, r_max=9.5)
# 2) Do the rank envelope test
res <- rank_envelope(curve_set)
# 3) Plot the test result
plot(res, plot_style="ggplot2", ylab=expression(italic(L[m](r)-L(r))))

# Make the test using instead the test function T(r) = \\hat{L}_mm(r);
# which is an estimator of the mark-weighted L function, L_mm(r),
# with translational edge correction (default).
curve_set <- random_labelling(mpp, mtf_name = 'mm', nsim=2499, r_min=1.5, r_max=9.5)
res <- rank_envelope(curve_set)
plot(res, plot_style="ggplot2", ylab=expression(italic(L[mm](r)-L(r))))

## Goodness-of-fit test (typically conservative, see dg.global_envelope for adjusted tests)
#-----------------------------------------------
pp <- unmark(spruces)
# Minimum distance between points in the pattern
min(nndist(pp))
# Fit a model
fittedmodel <- ppm(pp, interaction=Hardcore(hc=1)) # Hardcore process

\dontrun{
# Simulating Gibbs process by 'envelope' is slow, because it uses the MCMC algorithm
#env <- envelope(fittedmodel, fun="Jest", nsim=999, savefuns=TRUE,
                 correction="none", r=seq(0, 4, length=500))

# Using direct algorihm can be faster, because the perfect simulation is used here.
simulations <- NULL
for(j in 1:2499) {
   simulations[[j]] <- rHardcore(beta=exp(fittedmodel$coef[1]),
                                 R = fittedmodel$interaction$par$hc,
                                 W = pp$window);
   if(j\%\%10==0) cat(j, "...", sep="")
}
env <- envelope(pp, simulate=simulations, fun="Jest", nsim=length(simulations),
                savefuns=TRUE, correction="none", r=seq(0, 4, length=500))
curve_set <- crop_curves(env, r_min = 1, r_max = 3.5)
res <- rank_envelope(curve_set); plot(res, plot_style="ggplot2")
}

## A test based on a low dimensional random vector
#-------------------------------------------------
# Let us generate some example data.
X <- matrix(c(-1.6,1.6),1,2) # data pattern X=(X_1,X_2)
if(requireNamespace("mvtnorm", quietly = TRUE)) {
  Y <- mvtnorm::rmvnorm(200,c(0,0),matrix(c(1,0.5,0.5,1),2,2)) # simulations
  plot(Y, xlim=c(min(X[,1],Y[,1]), max(X[,1],Y[,1])), ylim=c(min(X[,2],Y[,2]), max(X[,2],Y[,2])))
  points(X, col=2)

  # Test the null hypothesis is that X is from the distribution of Y's (or if it is an outlier).

  # Case 1. The test vector is (X_1, X_2)
  cset1 <- create_curve_set(list(r=1:2, obs=as.vector(X), sim_m=t(Y)))
  res1 <- rank_envelope(cset1)
  plot(res1)

  # Case 2. The test vector is (X_1, X_2, (X_1-mean(Y_1))*(X_2-mean(Y_2))).
  t3 <- function(x, y) { (x[,1]-mean(y[,1]))*(x[,2]-mean(y[,2])) }
  cset2 <- create_curve_set(list(r=1:3, obs=c(X[,1],X[,2],t3(X,Y)), sim_m=rbind(t(Y), t3(Y,Y))))
  res2 <- rank_envelope(cset2)
  plot(res2)
}
}
\references{
Myllymäki, M., Mrkvička, T., Grabarnik, P., Seijo, H. and Hahn, U. (2017). Global envelope tests for spatial point patterns. Journal of the Royal Statistical Society: Series B (Statistical Methodology), 79: 381–404. doi: 10.1111/rssb.12172

Mrkvička, T., Myllymäki, M. and Hahn, U. (2017). Multiple Monte Carlo testing, with applications in spatial point processes. Statistics & Computing 27 (5): 1239-1255. doi: 10.1007/s11222-016-9683-9

Mrkvička, T., Hahn, U. and Myllymäki, M. (2018). A one-way ANOVA test for functional data with graphical interpretation. arXiv:1612.03608 [stat.ME]
}
\seealso{
\code{\link{random_labelling}}, \code{\link{plot.envelope_test}}
}
