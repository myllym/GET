% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/envelopes.r
\name{rank_envelope}
\alias{rank_envelope}
\title{The rank envelope test}
\usage{
rank_envelope(curve_set, type = "rank", ...)
}
\arguments{
\item{curve_set}{A curve_set (see \code{\link{create_curve_set}}) or an \code{\link[spatstat]{envelope}}
object. If an envelope object is given, it must contain the summary
functions from the simulated patterns which can be achieved by setting
savefuns = TRUE when calling \code{\link[spatstat]{envelope}}.}

\item{type}{The type of the global envelope with current options for "rank", "erl", "cont" and "area".
If "rank", the global rank envelope accompanied by the p-interval is given (Myllymäki et al., 2017).
If "erl", the global rank envelope based on extreme rank lengths accompanied by the extreme rank
length p-value is given (Myllymäki et al., 2017, Mrkvicka et al., 2018). See details and additional
sections thereafter.}

\item{...}{Additional parameters to be passed to \code{\link{global_envelope_test}}.}
}
\value{
An object of class "envelope_test", "envelope" and "fv" (see \code{\link[spatstat]{fv.object}}),
which can be printed and plotted directly.

Essentially a data frame containing columns
\itemize{
\item r = the vector of values of the argument r at which the test was made
\item obs = values of the test function for the data point pattern
\item lo = the lower envelope based on the simulated functions
\item hi = the upper envelope based on the simulated functions
\item central = If the curve_set (or envelope object) contains a component 'theo',
      then this function is used as the central curve and returned in this component.
      Otherwise, the central_curve is the mean of the test functions T_i(r), i=2, ..., s+1.
      Used for visualization only.
}
Additionally, the return value has attributes
\itemize{
  \item method = The name of the envelope test ("Rank envelope test" for the rank envelope test)
  \item alternative = The alternative specified in the function call.
  \item p = A point estimate for the p-value (default is the mid-rank p-value).
  \item p_interval = The p-value interval [p_liberal, p_conservative].
  \item ties = As the argument \code{ties}.
  \item k_alpha = The value of k corresponding to the 100(1-alpha)\% global envelope.
  \item k = Global rank values (for type="rank") or extreme rank lengths (for type="erl").
  k[1] is the value for the data pattern. Returned only if savedevs = TRUE.
  \item call = The call of the function.
}
and a punch of attributes for the "fv" object type, see \code{\link[spatstat]{fv}}.
}
\description{
The rank envelope test, p-values and global envelopes
}
\details{
The rank envelope test is a completely non-parametric test, which provides
the 100(1-alpha)\% global envelope for the chosen test function T(r) on
the chosen interval of distances and associated p-values.

The test corresponds to the global envelope test that can be carriet out by
\code{\link{global_envelope_test}} by specifying \code{type="rank"}.
}
\section{Global envelope}{

The 100(1-alpha)\% global envelope is provided in addition to the p-values. 
If \code{type="rank"} then the envelope is the global rank envelope proposed by
Myllymäki et al. (2017).
If \code{type="erl"} then the envelope is the global rank envelope based on the
extreme rank length ordering. This envelope is constructed as the convex hull of
the functions which have extreme rank length measure \eqn{R_i^{\text{erl}}}{Rerl_i}
that is larger or equal to the critical \eqn{\alpha}{alpha} level of the extreme rank
length measure (Mrkvička et al., 2018).
}

\section{Number of simulations}{

The extreme rank length ordering test (\code{type="erl"}) allows in principle a lower numbe
of simulations to be used than the test based on extreme ranks (\code{type="rank"}).
However, we recommend some thousands of simulations in any case to achieve a good power
and repeatability of the test.
}

\examples{

## Testing complete spatial randomness (CSR)
#-------------------------------------------
require(spatstat)
pp <- unmark(spruces)
# Generate nsim simulations under CSR, calculate L-function for the data and simulations
env <- envelope(pp, fun="Lest", nsim=2499, savefuns=TRUE, correction="translate",
                simulate=expression(runifpoint(pp$n, win=pp$window)))
# The rank envelope test
res <- rank_envelope(env,savedevs=TRUE)
# Plot the result.
# - The central curve is now obtained from env[['theo']], which is the
# value of the L-function under the null hypothesis (L(r) = r).
plot(res)
# or (requires R library ggplot2)
plot(res, plot_style="ggplot2")

## Advanced use:
# Choose the interval of distances [r_min, r_max] (at the same time create a curve_set from 'env')
curve_set <- crop_curves(env, r_min = 1, r_max = 7)
# For better visualisation, take the L(r)-r function
curve_set <- residual(curve_set, use_theo = TRUE)
# Do the rank envelope test
res <- rank_envelope(curve_set); plot(res, plot_style="ggplot2")

## Random labeling test
#----------------------
# requires library 'marksummary'
mpp <- spruces
# 1) Perform simulations under the random labelling hypothesis and calculate
# the test function T(r) for the data pattern (mpp) and each simulation.
# The command below specifies that the test function is T(r) = \\hat{L}_m(r),
# which is an estimator of the mark-weighted L function, L_m(r),
# with translational edge correction (default).
# The random_labelling function returns the centred functions \\hat{L}_m(r)-T_0(r),
# where T_0(r) = \\hat{L}(r) is the unmarked L function.
curve_set <- random_labelling(mpp, mtf_name = 'm', nsim=2499, r_min=1.5, r_max=9.5)
# 2) Do the rank envelope test
res <- rank_envelope(curve_set)
# 3) Plot the test result
plot(res, plot_style="ggplot2", ylab=expression(italic(L[m](r)-L(r))))

# Make the test using instead the test function T(r) = \\hat{L}_mm(r);
# which is an estimator of the mark-weighted L function, L_mm(r),
# with translational edge correction (default).
curve_set <- random_labelling(mpp, mtf_name = 'mm', nsim=2499, r_min=1.5, r_max=9.5)
res <- rank_envelope(curve_set)
plot(res, plot_style="ggplot2", ylab=expression(italic(L[mm](r)-L(r))))

## Goodness-of-fit test (typically conservative, see dg.global_envelope for adjusted tests)
#-----------------------------------------------
pp <- unmark(spruces)
# Minimum distance between points in the pattern
min(nndist(pp))
# Fit a model
fittedmodel <- ppm(pp, interaction=Hardcore(hc=1)) # Hardcore process

\dontrun{
# Simulating Gibbs process by 'envelope' is slow, because it uses the MCMC algorithm
#env <- envelope(fittedmodel, fun="Jest", nsim=999, savefuns=TRUE,
                 correction="none", r=seq(0, 4, length=500))

# Using direct algorihm can be faster, because the perfect simulation is used here.
simulations <- NULL
for(j in 1:2499) {
   simulations[[j]] <- rHardcore(beta=exp(fittedmodel$coef[1]),
                                 R = fittedmodel$interaction$par$hc,
                                 W = pp$window);
   if(j\%\%10==0) cat(j, "...", sep="")
}
env <- envelope(pp, simulate=simulations, fun="Jest", nsim=length(simulations),
                savefuns=TRUE, correction="none", r=seq(0, 4, length=500))
curve_set <- crop_curves(env, r_min = 1, r_max = 3.5)
res <- rank_envelope(curve_set); plot(res, plot_style="ggplot2")
}

## A test based on a low dimensional random vector
#-------------------------------------------------
# Let us generate some example data.
X <- matrix(c(-1.6,1.6),1,2) # data pattern X=(X_1,X_2)
if(requireNamespace("mvtnorm", quietly = TRUE)) {
  Y <- mvtnorm::rmvnorm(200,c(0,0),matrix(c(1,0.5,0.5,1),2,2)) # simulations
  plot(Y, xlim=c(min(X[,1],Y[,1]), max(X[,1],Y[,1])), ylim=c(min(X[,2],Y[,2]), max(X[,2],Y[,2])))
  points(X, col=2)

  # Test the null hypothesis is that X is from the distribution of Y's (or if it is an outlier).

  # Case 1. The test vector is (X_1, X_2)
  cset1 <- create_curve_set(list(r=1:2, obs=as.vector(X), sim_m=t(Y)))
  res1 <- rank_envelope(cset1)
  plot(res1)

  # Case 2. The test vector is (X_1, X_2, (X_1-mean(Y_1))*(X_2-mean(Y_2))).
  t3 <- function(x, y) { (x[,1]-mean(y[,1]))*(x[,2]-mean(y[,2])) }
  cset2 <- create_curve_set(list(r=1:3, obs=c(X[,1],X[,2],t3(X,Y)), sim_m=rbind(t(Y), t3(Y,Y))))
  res2 <- rank_envelope(cset2)
  plot(res2)
}
}
\references{
Myllymäki, M., Mrkvička, T., Grabarnik, P., Seijo, H. and Hahn, U. (2017). Global envelope tests for spatial point patterns. Journal of the Royal Statistical Society: Series B (Statistical Methodology), 79: 381–404. doi: 10.1111/rssb.12172

Mrkvička, T., Myllymäki, M. and Hahn, U. (2017). Multiple Monte Carlo testing, with applications in spatial point processes. Statistics & Computing 27 (5): 1239-1255. doi: 10.1007/s11222-016-9683-9

Mrkvička, T., Hahn, U. and Myllymäki, M. (2018). A one-way ANOVA test for functional data with graphical interpretation. arXiv:1612.03608 [stat.ME]
}
\seealso{
\code{\link{random_labelling}}, \code{\link{plot.envelope_test}}
}
