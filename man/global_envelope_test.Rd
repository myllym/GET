% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/envelopes.r
\name{global_envelope_test}
\alias{global_envelope_test}
\title{Global envelope test}
\usage{
global_envelope_test(curve_set, type = "rank", alpha = 0.05,
  savedevs = FALSE, alternative = c("two.sided", "less", "greater"),
  lexo = NULL, ties, probs = c(0.025, 0.975))
}
\arguments{
\item{curve_set}{A curve_set (see \code{\link{create_curve_set}})
or an \code{\link[spatstat]{envelope}} object containing a data function and simulated functions.
If an envelope object is given, it must contain the summary
functions from the simulated patterns which can be achieved by setting
savefuns = TRUE when calling \code{\link[spatstat]{envelope}}.}

\item{type}{The type of the global envelope with current options for 'rank', 'erl',
'qdir', 'st' and 'unscaled'. See details.}

\item{alpha}{The significance level. The 100(1-alpha)\% global envelope will be calculated.}

\item{savedevs}{Logical. Should the measure values k_i, i=1,...,s, be returned? Default: FALSE.}

\item{alternative}{A character string specifying the alternative hypothesis.
Must be one of the following: "two.sided" (default), "less" or "greater".
The last two options only available for \code{type = 'rank'} and \code{type = 'erl'}.}

\item{ties}{The method to obtain a unique p-value when  \code{type = 'rank'}.
Possible values are 'midrank', 'random', 'conservative', 'liberal' and 'erl'.
For 'conservative' the resulting p-value will be the highest possible.
For 'liberal' the p-value will be the lowest possible.
For 'random' the rank of the obs within the tied values is uniformly sampled so that the resulting
p-value is at most the conservative option and at least the liberal option.
For 'midrank' the mid-rank within the tied values is taken.
For 'erl' the extreme rank length p-value is calculated.
The default is 'midrank'.}

\item{probs}{A two-element vector containing the lower and upper
quantiles for the 'qdir' envelope, in that order and on the interval [0, 1].
The default values are 0.025 and 0.975, suggested by Myllymäki et al. (2015, 2017).}
}
\value{
An object of class "envelope_test", "envelope" and "fv"
(see \code{\link[spatstat]{fv.object}}), which can be printed and plotted directly.

Essentially a data frame containing columns
\itemize{
\item r = the vector of values of the argument r at which the test was made
\item obs = values of the data function
\item lo = the lower envelope based on the simulated functions
\item hi = the upper envelope based on the simulated functions
\item central = If the curve_set (or envelope object) contains a component 'theo',
      then this function is used as the central curve and returned in this component.
      Otherwise, the central_curve is the mean of the test functions T_i(r), i=2, ..., s+1.
      Used for visualization only.
}
Moreover, the return value has the same attributes as the object returned by
\code{\link{central_region}} and in addition
\itemize{
  \item p = A point estimate for the p-value (default is the mid-rank p-value).
}
and in the case that \code{type = 'rank'} also
\itemize{
  \item p_interval = The p-value interval [p_liberal, p_conservative].
  \item ties = As the argument \code{ties}.
}
}
\description{
Global envelope test, p-values and global envelopes
}
\details{
Given a \code{curve_set} (see \code{\link{create_curve_set}} for how to create such an object)
or an \code{\link[spatstat]{envelope}} object,
which contains both the data curve (or function or vector) \eqn{T_1(r)}{T_1(r)}
(in the component \code{obs}) and
the simulated curves \eqn{T_2(r),\dots,T_{s+1}(r)}{T_2(r),...,T_(s+1)(r)}
(in the component \code{sim_m}),
the function \code{global_envelope_test} performs a global envelope test.
The functionality of the function is rather similar to the function
\code{\link{central_region}}, but in addition to ordering the functions from
the most extreme one to the least extreme one using different measures
(see for detailed description of the options the details in \code{\link{central_region}} and
\code{\link{forder}}) and providing the global envelopes with intrinsic
graphical interpretation, p-values are calculated for the test.
Thus, while \code{\link{central_region}} can be used to construct global
envelope in a general setting, the function \code{\link{global_envelope_test}}
is devoted to testing as its name suggests.
}
\section{P-values}{

In the case \code{type="rank"}, based on the extreme ranks k_i, i=1, ..., s+1,
the p-interval is calculated. Because the extreme ranks contain ties, there is not just
one p-value. The p-interval is given by the most liberal and the most conservative p-value
estimate. This interval is by default plotted for the object returned by the rank_envelope function.
Also a single p-value is calculated and returned in the attribute \code{p}.
By default this single p-value is the mid-rank p-value, but another option can be used by
specifying \code{ties} argument.

If the case \code{type="erl"}, the (single) p-value based on the extreme rank length ordering
of the functions is calculated and returned in the attribute \code{p}.
}

\section{Number of simulations}{

The extreme rank length ordering test (\code{type='erl'}) similarly as
the MAD deviation/envelope tests \code{'qdir'}, \code{'st'} and \code{'unscaled'})
allow in principle a lower number of simulations to be used than the test based on
extreme ranks (\code{type='rank'}).
However, if affordable, we recommend some thousands of simulations in any case
to achieve a good power and repeatability of the test.
}

\examples{

## Testing complete spatial randomness (CSR)
#-------------------------------------------
require(spatstat)
pp <- unmark(spruces)
# Generate nsim simulations under CSR, calculate L-function for the data and simulations
env <- envelope(pp, fun="Lest", nsim=2499, savefuns=TRUE, correction="translate")
# The rank envelope test
res <- global_envelope_test(env, type="rank", savedevs=TRUE)
# Plot the result.
# - The central curve is now obtained from env[['theo']], which is the
# value of the L-function under the null hypothesis (L(r) = r).
plot(res)
# or (requires R library ggplot2)
plot(res, plot_style="ggplot2")

## Advanced use:
# Choose the interval of distances [r_min, r_max] (at the same time create a curve_set from 'env')
curve_set <- crop_curves(env, r_min = 1, r_max = 7)
# For better visualisation, take the L(r)-r function
curve_set <- residual(curve_set, use_theo = TRUE)
# Do the rank envelope test
res <- global_envelope_test(curve_set, type="rank"); plot(res, plot_style="ggplot2")

## Random labeling test
#----------------------
# requires library 'marksummary'
mpp <- spruces
# 1) Perform simulations under the random labelling hypothesis and calculate
# the test function T(r) for the data pattern (mpp) and each simulation.
# The command below specifies that the test function is T(r) = \\hat{L}_m(r),
# which is an estimator of the mark-weighted L function, L_m(r),
# with translational edge correction (default).
# The random_labelling function returns the centred functions \\hat{L}_m(r)-T_0(r),
# where T_0(r) = \\hat{L}(r) is the unmarked L function.
curve_set <- random_labelling(mpp, mtf_name = 'm', nsim=2499, r_min=1.5, r_max=9.5)
# 2) Do the rank envelope test
res <- global_envelope_test(curve_set, type="rank")
# 3) Plot the test result
plot(res, plot_style="ggplot2", ylab=expression(italic(L[m](r)-L(r))))

# Make the test using instead the test function T(r) = \\hat{L}_mm(r);
# which is an estimator of the mark-weighted L function, L_mm(r),
# with translational edge correction (default).
curve_set <- random_labelling(mpp, mtf_name = 'mm', nsim=2499, r_min=1.5, r_max=9.5)
res <- global_envelope_test(curve_set, type="rank")
plot(res, plot_style="ggplot2", ylab=expression(italic(L[mm](r)-L(r))))

## Goodness-of-fit test (typically conservative, see dg.global_envelope for adjusted tests)
#-----------------------------------------------
pp <- unmark(spruces)
# Minimum distance between points in the pattern
min(nndist(pp))
# Fit a model
fittedmodel <- ppm(pp, interaction=Hardcore(hc=1)) # Hardcore process

\dontrun{
# Simulating Gibbs process by 'envelope' is slow, because it uses the MCMC algorithm
#env <- envelope(fittedmodel, fun="Jest", nsim=999, savefuns=TRUE,
                 correction="none", r=seq(0, 4, length=500))

# Using direct algorihm can be faster, because the perfect simulation is used here.
simulations <- NULL
for(j in 1:999) {
   simulations[[j]] <- rHardcore(beta=exp(fittedmodel$coef[1]),
                                 R = fittedmodel$interaction$par$hc,
                                 W = pp$window)
   if(j\%\%10==0) cat(j, "...", sep="")
}
env <- envelope(pp, simulate=simulations, fun="Jest", nsim=length(simulations),
                savefuns=TRUE, correction="none", r=seq(0, 4, length=500))
curve_set <- crop_curves(env, r_min = 1, r_max = 3.5)
res <- global_envelope_test(curve_set, type="erl"); plot(res, plot_style="ggplot2")
}

## A test based on a low dimensional random vector
#-------------------------------------------------
# Let us generate some example data.
X <- matrix(c(-1.6,1.6),1,2) # data pattern X=(X_1,X_2)
if(requireNamespace("mvtnorm", quietly = TRUE)) {
  Y <- mvtnorm::rmvnorm(200,c(0,0),matrix(c(1,0.5,0.5,1),2,2)) # simulations
  plot(Y, xlim=c(min(X[,1],Y[,1]), max(X[,1],Y[,1])), ylim=c(min(X[,2],Y[,2]), max(X[,2],Y[,2])))
  points(X, col=2)

  # Test the null hypothesis is that X is from the distribution of Y's (or if it is an outlier).

  # Case 1. The test vector is (X_1, X_2)
  cset1 <- create_curve_set(list(r=1:2, obs=as.vector(X), sim_m=t(Y)))
  res1 <- global_envelope_test(cset1, type="rank")
  plot(res1)

  # Case 2. The test vector is (X_1, X_2, (X_1-mean(Y_1))*(X_2-mean(Y_2))).
  t3 <- function(x, y) { (x[,1]-mean(y[,1]))*(x[,2]-mean(y[,2])) }
  cset2 <- create_curve_set(list(r=1:3, obs=c(X[,1],X[,2],t3(X,Y)), sim_m=rbind(t(Y), t3(Y,Y))))
  res2 <- global_envelope_test(cset2, type="rank")
  plot(res2)
}
}
\references{
Myllymäki, M., Mrkvička, T., Grabarnik, P., Seijo, H. and Hahn, U. (2017). Global envelope tests for spatial point patterns. Journal of the Royal Statistical Society: Series B (Statistical Methodology), 79: 381–404. doi: 10.1111/rssb.12172

Mrkvička, T., Myllymäki, M. and Hahn, U. (2017). Multiple Monte Carlo testing, with applications in spatial point processes. Statistics & Computing 27 (5): 1239-1255. doi: 10.1007/s11222-016-9683-9

Mrkvička, T., Hahn, U. and Myllymäki, M. (2018). A one-way ANOVA test for functional data with graphical interpretation. arXiv:1612.03608 [stat.ME]
}
\seealso{
\code{\link{plot.envelope_test}}
}
